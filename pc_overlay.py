import open3d as o3d
import numpy as np
import os
import json

def load_lidar_point_cloud():
    """
    Load the final lidar point cloud generated by pc.py
    """
    lidar_path = "./data/object_sdf_data/lego/final_lidar_pcd.ply"
    
    if not os.path.exists(lidar_path):
        print(f"‚ùå Lidar point cloud not found at: {lidar_path}")
        print("Please run pc.py first to generate the final lidar point cloud")
        return None
    
    print(f"üìÅ Loading lidar point cloud from: {lidar_path}")
    lidar_pcd = o3d.io.read_point_cloud(lidar_path)
    print(f"‚úÖ Loaded lidar point cloud with {len(lidar_pcd.points)} points")
    
    return lidar_pcd

def load_nerfstudio_mesh():
    """
    Load the nerfstudio lego mesh.obj file
    """
    mesh_path = "./data/object_sdf_data/lego/exports/mesh_highres/mesh.obj"
    
    if not os.path.exists(mesh_path):
        print(f"‚ùå Nerfstudio mesh not found at: {mesh_path}")
        return None
    
    print(f"üìÅ Loading nerfstudio mesh from: {mesh_path}")
    mesh = o3d.io.read_triangle_mesh(mesh_path, enable_post_processing=True)

    # Check if mesh loaded successfully
    if not mesh.has_vertices():
        print("‚ùå Failed to load mesh vertices")
        return None
    
    print(f"‚úÖ Loaded nerfstudio mesh with {len(mesh.vertices)} vertices and {len(mesh.triangles)} triangles")
    
    # Debug: Print mesh bounds before transformation
    bbox_before = mesh.get_axis_aligned_bounding_box()
    print(f"üîç Mesh bounds before transformation: min={bbox_before.min_bound}, max={bbox_before.max_bound}")
    
    # Compute normals if not present
    if not mesh.has_vertex_normals():
        print("üîÑ Computing vertex normals...")
        mesh.compute_vertex_normals()


    with open("./data/object_sdf_data/lego/nerf_outputs/nerf_inputs/nerfacto/2025-07-19_175325/dataparser_transforms.json") as f:
        parser_data = json.load(f)


    T_scene = np.eye(4)
    T_scene[:3, :4] = parser_data["transform"]
    print(f"T_scene (4x4): {T_scene}")

    T_crop = np.diag([0.5, 0.5, 1.0, 1.0])


    scale = parser_data["scale"]

    # mesh.transform(np.linalg.inv(T_crop))

    mesh.scale(1/scale, center=(0, 0, 0)) 
    mesh.transform(np.linalg.inv(T_scene))

    # Calculate and print dimensions of the scaled mesh before centering
    bbox = mesh.get_axis_aligned_bounding_box()
    dimensions = bbox.max_bound - bbox.min_bound
    print(f"üìè Scaled Lego Mesh Dimensions (before centering):")
    print(f"   Width (X): {dimensions[0]:.4f} meters")
    print(f"   Height (Y): {dimensions[1]:.4f} meters") 
    print(f"   Depth (Z): {dimensions[2]:.4f} meters")
    print(f"   Volume: {dimensions[0] * dimensions[1] * dimensions[2]:.6f} cubic meters")
    print(f"   Bounding box center: {bbox.get_center()}")
    print(f"   Bounding box min: {bbox.min_bound}")
    print(f"   Bounding box max: {bbox.max_bound}")

    # Center the mesh about the origin
    center = bbox.get_center()
    print(f"üîÑ Centering mesh by translating by: {-center}")
    
    # Create translation matrix to move mesh to origin
    translation_matrix = np.eye(4)
    translation_matrix[:3, 3] = -center  # Negative center to move to origin
    mesh.transform(translation_matrix)
    
    # Print dimensions after centering
    bbox_centered = mesh.get_axis_aligned_bounding_box()
    dimensions_centered = bbox_centered.max_bound - bbox_centered.min_bound
    print(f"üìè Scaled Lego Mesh Dimensions (after centering):")
    print(f"   Width (X): {dimensions_centered[0]:.4f} meters")
    print(f"   Height (Y): {dimensions_centered[1]:.4f} meters") 
    print(f"   Depth (Z): {dimensions_centered[2]:.4f} meters")
    print(f"   Volume: {dimensions_centered[0] * dimensions_centered[1] * dimensions_centered[2]:.6f} cubic meters")
    print(f"   Bounding box center: {bbox_centered.get_center()}")
    print(f"   Bounding box min: {bbox_centered.min_bound}")
    print(f"   Bounding box max: {bbox_centered.max_bound}")

    o3d.io.write_triangle_mesh("./data/object_sdf_data/lego/exports/mesh_highres/mesh_scaled.obj", mesh)
    
    return mesh

def load_nerfstudio_point_cloud():
    """
    Load the nerfstudio lego point cloud with the same transformations as the mesh
    """
    pcd_path = "./data/object_sdf_data/lego/exports/pcd/point_cloud.ply"
    
    if not os.path.exists(pcd_path):
        print(f"‚ùå Nerfstudio point cloud not found at: {pcd_path}")
        return None
    
    print(f"üìÅ Loading nerfstudio point cloud from: {pcd_path}")
    pcd = o3d.io.read_point_cloud(pcd_path)
    
    # Check if point cloud loaded successfully
    if len(pcd.points) == 0:
        print("‚ùå Failed to load point cloud - no points found")
        return None
    
    print(f"‚úÖ Loaded nerfstudio point cloud with {len(pcd.points)} points")


    
    return pcd

def load_foundation_point_cloud():
    """
    Load the foundation point cloud
    """
    pcd_path = "./FoundationPose/debug/scene_complete.ply"
    
    if not os.path.exists(pcd_path):
        print(f"‚ùå Foundation point cloud not found at: {pcd_path}")
        return None
    
    print(f"üìÅ Loading foundation point cloud from: {pcd_path}")
    pcd = o3d.io.read_point_cloud(pcd_path)

    return pcd


def visualize_overlay(lidar_pcd, nerf_mesh, nerf_pcd=None, foundation_pcd=None):
    """
    Visualize the overlay of lidar point cloud, nerfstudio mesh, and nerfstudio point cloud
    """
    print("üé® Setting up visualization...")
    
    # Create visualizer
    vis = o3d.visualization.Visualizer()
    vis.create_window(window_name="Lidar + Nerfstudio Overlay", width=1200, height=800)
    
    # Add geometries to visualizer
    vis.add_geometry(nerf_mesh)
    vis.add_geometry(lidar_pcd)

    if nerf_pcd is not None:
        vis.add_geometry(nerf_pcd)
    
    if foundation_pcd is not None:
        vis.add_geometry(foundation_pcd)
    
    # Set mesh rendering properties for better visualization
    opt = vis.get_render_option()
    opt.mesh_show_back_face = True  # Show back faces of the mesh
    opt.mesh_show_wireframe = False  # Don't show wireframe by default
    
    # Paint the mesh with a distinct color for better visibility
    nerf_mesh.paint_uniform_color([0.7, 0.7, 1.0])  # Light blue color
    
    # Add nerfstudio point cloud if provided
    if nerf_pcd is not None:
        # Paint nerfstudio point cloud in a different color to distinguish it
        nerf_pcd.paint_uniform_color([0, 1, 0])  # Green color
        vis.add_geometry(nerf_pcd)
    
    # Create a sphere at origin (0,0,0) with radius 0.02
    sphere = o3d.geometry.TriangleMesh.create_sphere(radius=0.02)
    sphere.paint_uniform_color([1, 0, 0])  # Red color
    vis.add_geometry(sphere)
    
    # Create a bounding box wireframe around the mesh for debugging
    bbox = nerf_mesh.get_axis_aligned_bounding_box()
    bbox_wireframe = o3d.geometry.LineSet.create_from_axis_aligned_bounding_box(bbox)
    bbox_wireframe.paint_uniform_color([1, 1, 0])  # Yellow color
    vis.add_geometry(bbox_wireframe)

    # Set rendering options
    opt = vis.get_render_option()
    opt.background_color = np.asarray([0.1, 0.1, 0.1])  # Dark background
    opt.point_size = 2.0  # Larger points for better visibility
    opt.line_width = 1.0
    
    # Get bounding box of all geometries to set appropriate view
    all_geometries = [nerf_mesh, lidar_pcd]
    if nerf_pcd is not None:
        all_geometries.append(nerf_pcd)
    
    # Calculate combined bounding box
    all_min_bounds = []
    all_max_bounds = []
    
    for geom in all_geometries:
        if hasattr(geom, 'get_axis_aligned_bounding_box'):
            bbox = geom.get_axis_aligned_bounding_box()
            all_min_bounds.append(bbox.min_bound)
            all_max_bounds.append(bbox.max_bound)
        elif hasattr(geom, 'points') and len(geom.points) > 0:
            points = np.asarray(geom.points)
            min_bound = np.min(points, axis=0)
            max_bound = np.max(points, axis=0)
            all_min_bounds.append(min_bound)
            all_max_bounds.append(max_bound)
    
    if all_min_bounds and all_max_bounds:
        combined_min = np.min(all_min_bounds, axis=0)
        combined_max = np.max(all_max_bounds, axis=0)
        combined_bbox = o3d.geometry.AxisAlignedBoundingBox(combined_min, combined_max)
    else:
        # Fallback to default bounds
        combined_bbox = o3d.geometry.AxisAlignedBoundingBox([-1, -1, -1], [1, 1, 1])
    
    print(f"üîç Combined bounding box: min={combined_bbox.min_bound}, max={combined_bbox.max_bound}")
    center = combined_bbox.get_center()
    extent = combined_bbox.max_bound - combined_bbox.min_bound
    max_extent = np.max(extent)
    
    # Set initial view based on the actual geometry
    vis.get_view_control().set_front([0, 0, -1])
    vis.get_view_control().set_lookat(center)
    vis.get_view_control().set_up([0, -1, 0])
    vis.get_view_control().set_zoom(0.7)
    
    # Set a reasonable field of view
    vis.get_view_control().change_field_of_view(step=0.0)
    
    print("üéÆ Visualization controls:")
    print("- Mouse: Rotate view")
    print("- Mouse wheel: Zoom in/out")
    print("- Shift + Mouse: Pan view")
    print("- Q: Quit visualization")
    print("- H: Print help")
    
    # Run visualization
    print("üöÄ Starting visualization...")
    vis.run()
    vis.destroy_window()
    print("‚úÖ Visualization closed")

def analyze_alignment(lidar_pcd, nerf_mesh):
    """
    Analyze the alignment between lidar point cloud and nerfstudio mesh
    """
    print("\nüìä Alignment Analysis:")
    
    # Get bounding boxes
    lidar_bbox = lidar_pcd.get_axis_aligned_bounding_box()
    mesh_bbox = nerf_mesh.get_axis_aligned_bounding_box()
    
    print(f"Lidar bounding box:")
    print(f"  Min: {lidar_bbox.min_bound}")
    print(f"  Max: {lidar_bbox.max_bound}")
    print(f"  Size: {lidar_bbox.max_bound - lidar_bbox.min_bound}")
    
    print(f"Nerfstudio mesh bounding box:")
    print(f"  Min: {mesh_bbox.min_bound}")
    print(f"  Max: {mesh_bbox.max_bound}")
    print(f"  Size: {mesh_bbox.max_bound - mesh_bbox.min_bound}")
    
    # Calculate centers
    lidar_center = lidar_bbox.get_center()
    mesh_center = mesh_bbox.get_center()
    
    print(f"Centers:")
    print(f"  Lidar center: {lidar_center}")
    print(f"  Mesh center: {mesh_center}")
    print(f"  Center difference: {np.linalg.norm(lidar_center - mesh_center):.4f}")

def main():
    """
    Main function to overlay lidar point cloud with nerfstudio mesh and point cloud
    """
    print("üîç Lidar + Nerfstudio Overlay")
    print("=" * 50)
    
    # Load lidar point cloud
    lidar_pcd = load_lidar_point_cloud()
    if lidar_pcd is None:
        return
    
    # Load nerfstudio mesh
    nerf_mesh = load_nerfstudio_mesh()
    if nerf_mesh is None:
        return
    
    # Load nerfstudio point cloud
    nerf_pcd = load_nerfstudio_point_cloud()
    if nerf_pcd is None:
        print("‚ö†Ô∏è  Nerfstudio point cloud not available, continuing with mesh only")
        nerf_pcd = None

    # Load foundation point cloud
    foundation_pcd = load_foundation_point_cloud()
    if foundation_pcd is None:
        print("‚ö†Ô∏è  Foundation point cloud not available, continuing with mesh only")
        foundation_pcd = None

    # Analyze alignment
    analyze_alignment(lidar_pcd, nerf_mesh)
    
    # Visualize overlay
    visualize_overlay(lidar_pcd, nerf_mesh, nerf_pcd, foundation_pcd)

if __name__ == "__main__":
    main() 

    mesh = o3d.io.read_triangle_mesh("./data/object_sdf_data/lego/exports/mesh_highres/mesh_scaled.obj", enable_post_processing=True)
    bbox = mesh.get_axis_aligned_bounding_box()
    print(f"üîç Mesh bounds: min={bbox.min_bound}, max={bbox.max_bound}")
    print(f"üîç Mesh center: {bbox.get_center()}")
    print(f"üîç Mesh size: {bbox.max_bound - bbox.min_bound}")
    print(f"üîç Mesh volume: {bbox.volume()}")

    bbox.color = [1, 0, 0]

    o3d.visualization.draw_geometries([mesh, bbox])



